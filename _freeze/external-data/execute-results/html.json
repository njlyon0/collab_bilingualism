{
  "hash": "12678504d4f05c45dce38483837a2667",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Starting with Data\"\nengine: knitr\ncode-annotations: hover\n---\n\n\n## Library Loading\n\nBegin by loading any needed libraries.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nLoad the `tidyverse` meta-package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load needed library\nlibrary(tidyverse)\n```\n:::\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nLoad the `pandas` and `os` libraries.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Load needed libraries\nimport os\nimport pandas as pd\n```\n:::\n\n:::\n\n## Data Import\n\nWe can now load an external dataset derived from the `lterdatasampler` [{{< fa brands r-project >}} R]{.r} package (see [here](https://lter.github.io/lterdatasampler/)) with both [{{< fa brands r-project >}} R]{.r} and [{{< fa brands python >}} Python]{.py}. This relatively simple operation is also a nice chance to showcase how 'namespacing' (i.e., indicating which package a given function comes from) differs between the two languages.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nNamespacing in [{{< fa brands r-project >}} R]{.r} is accomplished by doing `package_name::function_name` and is optional (though, in my opinion, good practice!). Note that we use the assignment operator (`<-`) to assign the contents of the CSV to an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in vertebrate data CSV\nvert_r <- utils::read.csv(file = file.path(\"data\", \"verts.csv\"))\n```\n:::\n\n\nRecall from our file path module that the `file.path` function accounts for computer operating system differences.\n\n## [{{< fa brands python >}} Python]{.py}\n\nIn [{{< fa brands python >}} Python]{.py}, namespacing is required and is done via `package_name.function_name`. Note that we use the assignment operator (`=`) to assign the contents of the CSV to a variable.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Read in vertebrate data CSV\nvert_py = pd.read_csv(os.path.join(\"data\", \"verts.csv\"))\n```\n:::\n\n\nRecall from our file path module that the `join` function accounts for computer operating system differences.\n:::\n\n## Tabular Data [Type]{.py}/[Class]{.r}\n\nData stored in CSVs (and similar data formats like Microsoft Excel, etc.) has a unique [type]{.py}/[class]{.r} that differs from some of the categories we covered in the \"Fundamentals\" section.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nIn [{{< fa brands r-project >}} R]{.r}, such data are class `data.frame`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check class of a data object\nclass(vert_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nIn [{{< fa brands python >}} Python]{.py}, such data are type `DataFrame` and this variable type is defined by the `pandas` library. This is the standard type returned by the `pandas` `read_csv` function.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check type of a data object\ntype(vert_py)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\n```\n\n\n:::\n:::\n\n:::\n\n## Making Heads or Tails of Data\n\nChecking the 'head' or 'tail' of the data (i.e., the first or last few rows of the data respectively) is a nice way of getting a sense for the general format of the dataframe being assessed.\n\n::: panel-tabset\n## `<svg aria-label=\"R Project\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#FF9B00;overflow:visible;position:relative;\"><title>R Project</title><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} R\n\nIn [{{< fa brands r-project >}} R]{.r}, we use the `head` or `tail` function to return the first or last rows respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check out head\nutils::head(vert_r, n = 2) # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year sitecode section reach pass unitnum unittype vert_index pitnumber\n1 1987 MACKCC-L      CC     L    1       1        R          1        NA\n2 1987 MACKCC-L      CC     L    1       1        R          2        NA\n          species length_1_mm length_2_mm weight_g clip sampledate notes\n1 Cutthroat trout          58          NA     1.75 NONE 1987-10-07      \n2 Cutthroat trout          61          NA     1.95 NONE 1987-10-07      \n```\n\n\n:::\n:::\n\n1. Note that we're using the _optional_ `n` argument to specify the number of rows to return\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check out tail\nutils::tail(vert_r, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      year sitecode section reach pass unitnum unittype vert_index pitnumber\n32207 2019 MACKOG-U      OG     U    2      16        C         24   1043547\n32208 2019 MACKOG-U      OG     U    2      16        C         25   1043583\n32209 2019 MACKOG-U      OG     U    2      16        C         26   1043500\n                       species length_1_mm length_2_mm weight_g clip sampledate\n32207 Coastal giant salamander          67         120      9.6 NONE 2019-09-05\n32208 Coastal giant salamander          74         131     14.3 NONE 2019-09-05\n32209 Coastal giant salamander          73         128     11.6 NONE 2019-09-05\n            notes\n32207            \n32208            \n32209 Terrestrial\n```\n\n\n:::\n:::\n\n\n## `<svg aria-label=\"Python\" role=\"img\" viewBox=\"0 0 448 512\" style=\"height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#077DC2;overflow:visible;position:relative;\"><title>Python</title><path d=\"M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z\"/></svg>`{=html} Python\n\nIn [{{< fa brands python >}} Python]{.py}, we use the `head` or `tail` method to return the first or last rows respectively. Note that these methods are only available to variables of type `DataFrame`. All methods are appended to the end of the variable of the appropriate type separated by a period.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check out head\nvert_py.head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   year  sitecode section reach  ...  weight_g  clip  sampledate  notes\n0  1987  MACKCC-L      CC     L  ...      1.75  NONE  1987-10-07    NaN\n1  1987  MACKCC-L      CC     L  ...      1.95  NONE  1987-10-07    NaN\n2  1987  MACKCC-L      CC     L  ...      5.60  NONE  1987-10-07    NaN\n\n[3 rows x 16 columns]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check out tail\nvert_py.tail(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       year  sitecode section reach  ...  weight_g  clip  sampledate        notes\n32207  2019  MACKOG-U      OG     U  ...      14.3  NONE  2019-09-05          NaN\n32208  2019  MACKOG-U      OG     U  ...      11.6  NONE  2019-09-05  Terrestrial\n\n[2 rows x 16 columns]\n```\n\n\n:::\n:::\n\n:::\n\n## Data Structure\n\nWhile it is nice to know the [type]{.py}/[class]{.r} of the data table generally, we often need to know the [type]{.py}/[class]{.r} of the columns within those data tables. Our operations are typically aimed at modifying particular columns and pre-requisite to that is knowing the [type]{.py}/[class]{.r} of the column to know what actions are available to us.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\n[{{< fa brands r-project >}} R]{.r} uses the `str` function to assess data structure. Structure includes the dimensions of the data (i.e., number of rows and columns) as well as the class of the data (`data.frame`) and the class of each column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::str(vert_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t32209 obs. of  16 variables:\n $ year       : int  1987 1987 1987 1987 1987 1987 1987 1987 1987 1987 ...\n $ sitecode   : chr  \"MACKCC-L\" \"MACKCC-L\" \"MACKCC-L\" \"MACKCC-L\" ...\n $ section    : chr  \"CC\" \"CC\" \"CC\" \"CC\" ...\n $ reach      : chr  \"L\" \"L\" \"L\" \"L\" ...\n $ pass       : int  1 1 1 1 1 1 1 1 1 1 ...\n $ unitnum    : num  1 1 1 1 1 1 1 1 1 1 ...\n $ unittype   : chr  \"R\" \"R\" \"R\" \"R\" ...\n $ vert_index : int  1 2 3 4 5 6 7 8 9 10 ...\n $ pitnumber  : int  NA NA NA NA NA NA NA NA NA NA ...\n $ species    : chr  \"Cutthroat trout\" \"Cutthroat trout\" \"Cutthroat trout\" \"Cutthroat trout\" ...\n $ length_1_mm: int  58 61 89 58 93 86 107 131 103 117 ...\n $ length_2_mm: int  NA NA NA NA NA NA NA NA NA NA ...\n $ weight_g   : num  1.75 1.95 5.6 2.15 6.9 5.9 10.5 20.6 9.55 13 ...\n $ clip       : chr  \"NONE\" \"NONE\" \"NONE\" \"NONE\" ...\n $ sampledate : chr  \"1987-10-07\" \"1987-10-07\" \"1987-10-07\" \"1987-10-07\" ...\n $ notes      : chr  \"\" \"\" \"\" \"\" ...\n```\n\n\n:::\n:::\n\n\nBe careful to not confuse this with the [{{< fa brands python >}} Python]{.py} function `str` that coerces values to type \"string\"!\n\n## [{{< fa brands python >}} Python]{.py}\n\nWhen we want to know the type of each column in a [{{< fa brands python >}} Python]{.py} `DataFrame`, we can use the `dtypes` \"attribute\". Attributes are akin to a method but they completely lack arguments that might modify their behavior. As a consequence they are extremely precisely defined. The `dtypes` attribute returns the type of each column.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvert_py.dtypes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nyear             int64\nsitecode        object\nsection         object\nreach           object\npass             int64\nunitnum        float64\nunittype        object\nvert_index       int64\npitnumber      float64\nspecies         object\nlength_1_mm    float64\nlength_2_mm    float64\nweight_g       float64\nclip            object\nsampledate      object\nnotes           object\ndtype: object\n```\n\n\n:::\n:::\n\n:::\n\n## Data Summaries\n\nWe often want to begin our exploration of a given dataset by getting a summary of each column. This is rarely what we actually need for statistics or visualization but it is a nice high-level way of getting a sense for the composition of the data.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\n[{{< fa brands r-project >}} R]{.r} provides the `summary` function to summarize all columns in a dataset. Note that it is not terribly informative for columns of class character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get summary of data\nsummary(vert_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      year        sitecode           section             reach          \n Min.   :1987   Length:32209       Length:32209       Length:32209      \n 1st Qu.:1998   Class :character   Class :character   Class :character  \n Median :2006   Mode  :character   Mode  :character   Mode  :character  \n Mean   :2005                                                           \n 3rd Qu.:2012                                                           \n Max.   :2019                                                           \n                                                                        \n      pass          unitnum         unittype           vert_index    \n Min.   :1.000   Min.   : 1.000   Length:32209       Min.   :  1.00  \n 1st Qu.:1.000   1st Qu.: 3.000   Class :character   1st Qu.:  5.00  \n Median :1.000   Median : 7.000   Mode  :character   Median : 13.00  \n Mean   :1.224   Mean   : 7.696                      Mean   : 20.17  \n 3rd Qu.:1.000   3rd Qu.:11.000                      3rd Qu.: 27.00  \n Max.   :2.000   Max.   :20.000                      Max.   :147.00  \n                                                                     \n   pitnumber          species           length_1_mm      length_2_mm   \n Min.   :   62048   Length:32209       Min.   : 19.00   Min.   : 28.0  \n 1st Qu.:13713632   Class :character   1st Qu.: 47.00   1st Qu.: 77.0  \n Median :18570447   Mode  :character   Median : 63.00   Median : 98.0  \n Mean   :16286432                      Mean   : 73.83   Mean   :100.5  \n 3rd Qu.:19132429                      3rd Qu.: 97.00   3rd Qu.:119.0  \n Max.   :28180046                      Max.   :253.00   Max.   :284.0  \n NA's   :26574                         NA's   :17       NA's   :19649  \n    weight_g           clip            sampledate           notes          \n Min.   :  0.090   Length:32209       Length:32209       Length:32209      \n 1st Qu.:  1.510   Class :character   Class :character   Class :character  \n Median :  6.050   Mode  :character   Mode  :character   Mode  :character  \n Mean   :  8.903                                                           \n 3rd Qu.: 11.660                                                           \n Max.   :134.590                                                           \n NA's   :13268                                                             \n```\n\n\n:::\n:::\n\n\n## [{{< fa brands python >}} Python]{.py}\n\n[{{< fa brands python >}} Python]{.py} has the `describe` method for getting similar information about each column of a `DataFrame`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Describe data\nvert_py.describe()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               year          pass  ...   length_2_mm      weight_g\ncount  32209.000000  32209.000000  ...  12560.000000  18941.000000\nmean    2004.917601      1.223664  ...    100.485191      8.902859\nstd        8.572474      0.416706  ...     34.736955     10.676276\nmin     1987.000000      1.000000  ...     28.000000      0.090000\n25%     1998.000000      1.000000  ...     77.000000      1.510000\n50%     2006.000000      1.000000  ...     98.000000      6.050000\n75%     2012.000000      1.000000  ...    119.000000     11.660000\nmax     2019.000000      2.000000  ...    284.000000    134.590000\n\n[8 rows x 8 columns]\n```\n\n\n:::\n:::\n\n\n[{{< fa brands python >}} Python]{.py} also offers the `info` method to identify only the count of non-null entries in each column as well as the type of each column.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check info of data\nvert_py.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 32209 entries, 0 to 32208\nData columns (total 16 columns):\n #   Column       Non-Null Count  Dtype  \n---  ------       --------------  -----  \n 0   year         32209 non-null  int64  \n 1   sitecode     32209 non-null  object \n 2   section      32209 non-null  object \n 3   reach        32209 non-null  object \n 4   pass         32209 non-null  int64  \n 5   unitnum      32209 non-null  float64\n 6   unittype     31599 non-null  object \n 7   vert_index   32209 non-null  int64  \n 8   pitnumber    5635 non-null   float64\n 9   species      32206 non-null  object \n 10  length_1_mm  32192 non-null  float64\n 11  length_2_mm  12560 non-null  float64\n 12  weight_g     18941 non-null  float64\n 13  clip         32209 non-null  object \n 14  sampledate   32209 non-null  object \n 15  notes        3174 non-null   object \ndtypes: float64(5), int64(3), object(8)\nmemory usage: 3.9+ MB\n```\n\n\n:::\n:::\n\n:::\n\n## Identifying Columns\n\nIf we want to skip these steps and just identify the full set of column [labels]{.py}/[names]{.r} there is a small operation for stripping that information out in both languages.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\n[{{< fa brands r-project >}} R]{.r} has the `names` function to quickly return a vector of the column names in a given `data.frame` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check column names\nnames(vert_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"year\"        \"sitecode\"    \"section\"     \"reach\"       \"pass\"       \n [6] \"unitnum\"     \"unittype\"    \"vert_index\"  \"pitnumber\"   \"species\"    \n[11] \"length_1_mm\" \"length_2_mm\" \"weight_g\"    \"clip\"        \"sampledate\" \n[16] \"notes\"      \n```\n\n\n:::\n:::\n\n\n## [{{< fa brands python >}} Python]{.py}\n\n[{{< fa brands python >}} Python]{.py} has the `columns` attributes for returning a simple list of column labels in a given `DataFrame` variable.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check column labels\nvert_py.columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIndex(['year', 'sitecode', 'section', 'reach', 'pass', 'unitnum', 'unittype',\n       'vert_index', 'pitnumber', 'species', 'length_1_mm', 'length_2_mm',\n       'weight_g', 'clip', 'sampledate', 'notes'],\n      dtype='object')\n```\n\n\n:::\n:::\n\n:::\n\n## Accessing Column(s)\n\nWe may want to access a particular column or set of columns. There are several approaches we might use to access a particular column in either [{{< fa brands python >}} Python]{.py} or [{{< fa brands r-project >}} R]{.r}. They are:\n\n- Indexing the column by its location\n- Indexing the column by its [label]{.py}/[name]{.r}\n- Indexing the column with an operator\n\nIn all of the following examples we'll use the `head` [method]{.py}/[function]{.r} to simplify the output.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nIf we know the order of the columns we can use the same syntax as when we indexed a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use column indexing\nhead(vert_r[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year\n1 1987\n2 1987\n3 1987\n4 1987\n5 1987\n6 1987\n```\n\n\n:::\n:::\n\n\nNote that if we also want to account for rows we would put the desired column number on the right and the desired row number on the left.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use row/column indexing\nhead(vert_r[, 1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1987 1987 1987 1987 1987 1987\n```\n\n\n:::\n:::\n\n\nIf preferred we could instead substitute the number for the column name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(vert_r[\"year\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year\n1 1987\n2 1987\n3 1987\n4 1987\n5 1987\n6 1987\n```\n\n\n:::\n:::\n\n\nIn [{{< fa brands r-project >}} R]{.r}, the column operator is a `$` and we place that character between the object and column names (e.g., `data_name$column_name`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(vert_r$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1987 1987 1987 1987 1987 1987\n```\n\n\n:::\n:::\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nIf we know the index position of the desired column we can use the `iloc` method (short for \"integer location\"). Note that the `iloc` method uses square brackets instead of parentheses (typical methods use parentheses). We must include a colon with either nothing or the start/stop bounds (see \"Slicing\" in \"Fundamentals\"). A colon without specifying bounds returns all rows.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Use row/column indexing\nvert_py.iloc[: , 0].head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    1987\n1    1987\n2    1987\n3    1987\n4    1987\nName: year, dtype: int64\n```\n\n\n:::\n:::\n\n\nIf preferred we could instead substitute the number for the column label.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvert_py[\"year\"].head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    1987\n1    1987\n2    1987\n3    1987\n4    1987\nName: year, dtype: int64\n```\n\n\n:::\n:::\n\n\nIn [{{< fa brands python >}} Python]{.py}, the column operator is a `.` and we place that character between the variable name and column label (e.g., `data_name.column_name`).\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvert_py.year.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    1987\n1    1987\n2    1987\n3    1987\n4    1987\nName: year, dtype: int64\n```\n\n\n:::\n:::\n\n:::\n\nWhen we want to access multiple columns we can still use either index positions or column [labels]{.py}/[names]{.r} but we _cannot_ use the column operator.\n\nWe'll continue to use the `head` [method]{.py}/[function]{.r} to simplify outputs.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nIn [{{< fa brands r-project >}} R]{.r} we could use a concatenated vector of index positions to specify particular columns by their positions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use multiple column index positions\nhead(vert_r[, c(1:2, 13)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year sitecode weight_g\n1 1987 MACKCC-L     1.75\n2 1987 MACKCC-L     1.95\n3 1987 MACKCC-L     5.60\n4 1987 MACKCC-L     2.15\n5 1987 MACKCC-L     6.90\n6 1987 MACKCC-L     5.90\n```\n\n\n:::\n:::\n\n\nInstead we could use a vector of column names for extra precision.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use multiple column names\nhead(vert_r[, c(\"year\", \"sitecode\", \"weight_g\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year sitecode weight_g\n1 1987 MACKCC-L     1.75\n2 1987 MACKCC-L     1.95\n3 1987 MACKCC-L     5.60\n4 1987 MACKCC-L     2.15\n5 1987 MACKCC-L     6.90\n6 1987 MACKCC-L     5.90\n```\n\n\n:::\n:::\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nIn [{{< fa brands python >}} Python]{.py} we could use the `iloc` method for multiple columns and simply supply a list of the column index positions in which we are interested. Note that this method is different from many of the other methods we've covered so far because it uses square brackets instead of parentheses.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Use multiple column index positions\nvert_py.iloc[:, [0, 1, 12]].head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   year  sitecode  weight_g\n0  1987  MACKCC-L      1.75\n1  1987  MACKCC-L      1.95\n2  1987  MACKCC-L      5.60\n3  1987  MACKCC-L      2.15\n4  1987  MACKCC-L      6.90\n```\n\n\n:::\n:::\n\n\nOr we could use the `.loc` method and supply a list of column labels. Note that the `loc` method also uses square brackets instead of parentheses and requires a colon to the left of the comma in order to return all rows.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvert_py.loc[:, [\"year\", \"sitecode\", \"weight_g\"]].head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   year  sitecode  weight_g\n0  1987  MACKCC-L      1.75\n1  1987  MACKCC-L      1.95\n2  1987  MACKCC-L      5.60\n3  1987  MACKCC-L      2.15\n4  1987  MACKCC-L      6.90\n```\n\n\n:::\n:::\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}