{
  "hash": "9df87bb97a8ab5cfb1e42d55ab39b91e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Workflow Automation\"\n---\n\n\n\n\n## Loops\n\nOften we want to perform some set of operations repeatedly across a known number of iterations. For example, maybe we want to subset a given data file into a separate [variable]{.py}/[object]{.r} by month of data collection and export the resulting file as a CSV. We _could_ simply copy/paste our 'subset and export' code as many times as needed but this can be error-prone. Also, it is cumbersome to manually update all copies of the relevant code when you identify a possible improvement. \n\nOne code solution to this is to **automate** the workflow using `for` loops (casually referred to more simply as just \"loops\"). The syntax of [{{< fa brands python >}}]{.py} [Python]{.py} and [{{< fa brands r-project >}}]{.r} [R]{.r} is very similar for loops--likely because this is such a fundamental operation to any coding language!\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nMake a simple object to demonstrate loops.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a vector of animal types\nzoo_r <- c(\"lion\", \"tiger\", \"crocodile\", \"vulture\", \"hippo\")\n\n# Check that out\nzoo_r\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lion\"      \"tiger\"     \"crocodile\" \"vulture\"   \"hippo\"    \n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nMake a simple variable to demonstrate loops.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Make a list of animal types\nzoo_py = [\"lion\", \"tiger\", \"crocodile\", \"vulture\", \"hippo\"]\n\n# Check that out\nzoo_py\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['lion', 'tiger', 'crocodile', 'vulture', 'hippo']\n```\n\n\n:::\n:::\n\n\n\n:::\n\nWith this simple [variable]{.py}/[object]{.r} in-hand we can now demonstrate the core facets of loops.\n\n### Fundamental Components\n\nLoops (in either language) require a few core components in order to work properly:\n\n1. `for` statement -- defines the start of the loop-definition component\n2. \"Loop [variable]{.py}/[object]{.r}\" -- essentially a placeholder [variable]{.py}/[object]{.r} whose value will change with each iteration of the loop\n3. `in` statement -- relates loop [variable]{.py}/[object]{.r} to set of [list]{.py}/[vector]{.r} to iterate across\n4. [list]{.py}/[vector]{.r} to iterate across -- set of values to iterate across\n5. Actual workflow! -- operations to perform on each iteration of the loop\n\nTo see in this syntax in action we'll use a simple loop that prints each animal type in the [list]{.py}/[vector]{.r} we created above.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nIn [{{< fa brands r-project >}}]{.r} [R]{.r}, the `for` statement requires parentheses around the loop object, the `in` statement, and the vector to iterate across. The operation(s) performed in each iteration _must_ be wrapped in curly braces (`{...}`).\n\nWhen the code reaches the closing curly brace it returns to the top of the workflow and begins again with the next element of the provided vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For each animal in the zoo\nfor(animal in zoo_r){\n  \n  # Print its name\n  print(animal)\n  \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lion\"\n[1] \"tiger\"\n[1] \"crocodile\"\n[1] \"vulture\"\n[1] \"hippo\"\n```\n\n\n:::\n:::\n\n\n\n\nNote that when we are done the loop object still exists and is set to the last element of the vector we iterated across.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check current value of `animal` object\nanimal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hippo\"\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nIn [{{< fa brands python >}}]{.py} [Python]{.py}, the `for` statement, loop variable, `in` statement, and list to iterate across do not use parentheses but the end of the line requires a colon `:`. The operation(s) performed in each iteration _must_ be indentened one level (i.e., press \"tab\" once or \"space\" four times).\n\nWhen the code reaches the end of the indented lines it returns to the top of the workflow and begins again with the next item of the provided list.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# For each animal in the zoo\nfor animal in zoo_py:\n  # Print its name\n  print(animal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlion\ntiger\ncrocodile\nvulture\nhippo\n```\n\n\n:::\n:::\n\n\n\n\nNote that when we are done the loop variable still exists and is set to the last item of the list we iterated across.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check current value of `animal` variable\nanimal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'hippo'\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Loops & Conditionals\n\nWe can also build conditional statements into a loop to create a loop that can flexibly handle different outcomes. We have discussed conditional operators elsewhere so we'll only explain the parts of loop conditionals that we haven't already discussed. To demonstrate, we can loop across a set of numbers and use conditionals to print whether the values are greater/less than or equal to zero.\n\nIn the example below we'll use three new statements `if`, `else if` and `else`. Each condition only performs its operation when its condition is met (i.e., returns [True]{.py}/[TRUE]{.r}).\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nThese three statements all have similar syntax to the `for` statement in that they evaluate something in parentheses and then perform some operation(s) in curly braces. They do differ slightly in context however:\n\n- `if` can only be used first (or in cases where there is only `if` and `else`)\n- `else if` can only be used after `if` (or after another `else if`) and _allows for specifying another condition._\n- `else` can only be used at the end; catches only cases that _don't_ meet one of the prior conditions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop across numbers\nfor(j in c(-2, -1, 0, 1, 2)){\n  \n  # If less than 0\n  if(j < 0){ \n    print(paste(j, \"is negative\")) \n    }\n  \n  # If greater than 0\n  else if(j > 0){\n    print(paste(j, \"is positive\"))\n  }\n  \n  # If neither of those, then it must be 0!\n  else { \n    print(paste(j, \"is zero!\"))\n    }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"-2 is negative\"\n[1] \"-1 is negative\"\n[1] \"0 is zero!\"\n[1] \"1 is positive\"\n[1] \"2 is positive\"\n```\n\n\n:::\n:::\n\n\n\n\nNote that to get the message to print correctly we needed to wrap a `paste` function in `print` to assemble multiple things into a single object.\n\n## [{{< fa brands python >}} Python]{.py}\n\nThese three statements all have similar syntax to the `for` statement in that they evaluate something before a colon and then perform some operation(s) after that colon. They do differ slightly in context however:\n\n- `if` can only be used first (or in cases where there is only `if` and `else`)\n- `elif` can only be used after `if` (or after another `elif`) and _allows for specifying another condition._\n- `else` can only be used at the end; catches only cases that _don't_ meet one of the prior conditions\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Loop across numbers\nfor k in [-2, -1, 0, 1, 2]:\n  \n  # If less than 0\n  if k < 0: \n    print(str(k) + \" is negative\")\n    \n  # If greater than 0\n  elif k > 0:\n    print(str(k) + \" is positive\")\n  \n  # If neither of those, then it must be 0!\n  else:\n    print(str(k) + \" is zero!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n-2 is negative\n-1 is negative\n0 is zero!\n1 is positive\n2 is positive\n```\n\n\n:::\n:::\n\n\n\n\nNote that to get the message to print correctly we needed to coerce the loop variable into type string (using the `str` function).\n:::\n\n## \"Custom\" Functions\n\nLoops are a really powerful tool but they are limited in some ways. Sometimes we want to do a task once per project but only use it once in each instance. Such an operation is certainly \"repeated\" but not really the same context in which a loop makes sense. We can create reusable modular code to fit these circumstances by writing our own custom functions--\"custom\" in the sense that we write them ourselves rather than load them from a particular library.\n\nLet's write a simple function in both languages that simply multiplies two arguments by one another and returns the result.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nGenerating a function in [{{< fa brands r-project >}}]{.r} [R]{.r} shares some syntax elements with loops and conditional statements! In this case we use the `function` function to preserve our work as a function, then provide any needed arguments in parentheses, and end with curly braces with the operation(s) performed by the function inside. If the function produces something that we want to give back to the user, we need to specify that with the `return` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiplication function\nmult_r <- function(p, q){\n  \n  # Multiply the two values\n  result_r <- p * q\n  \n  # Return that\n  return(result_r)\n}\n\n# Once defined, we can invoke the function like we would any other\nmult_r(p = 2, q = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nGenerating a function in [{{< fa brands python >}}]{.py} [Python]{.py} shares some syntax elements with loops and conditional statements! In this case we use the `def` statement then provide the name and--parenthetically--any needed arguments for our new function. If the function produces something that we want to give back to the user, we need to specify that by using the `return` statement.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Multiplication function\ndef mult_py(n, i):\n  # Add docstrings for later use (see below)\n  \"\"\"\n  Multiply two values by one another.\n  \n  n -- First value to multiply\n  i -- Second value to multiply\n  \"\"\"\n  \n  # Multiply the two values\n  result_py = n * i\n  \n  # Return them\n  return result_py\n\n# Once defined, we can invoke the function like we would any other\nmult_py(n = 2, i = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n10\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Function Documentation\n\nOne component of custom functions to be aware of is their somewhat variable documentation. \"Official\" functions tend to be really well documented but custom functions have no required documentation. However, there are some best practices that we can try to follow ourselves to make life as easy as possible for people trying to intuit our functions' purposes (including ourselves in the future!).\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nR contains no native mode of specifying function documentation! While there are tools to formalize this when functions are part of a formal package (see [roxygen2 formatting](https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html)) our custom functions _cannot_ include documentation. That said, <u>it is still good practice to include plain-language comment lines that describe the function's operations</u> even when they will only be visible where the function is defined.\n\nNote that the [`docstring` package](https://cran.r-project.org/web/packages/docstring/vignettes/docstring_intro.html) for [{{< fa brands r-project >}}]{.r} [R]{.r} simulates [{{< fa brands python >}}]{.py} [Python]{.py}-style docstrings for [{{< fa brands r-project >}}]{.r} [R]{.r} functions but is not part of \"base\" R.\n\n## [{{< fa brands python >}} Python]{.py}\n\n[{{< fa brands python >}} Python]{.py} custom functions allow us to specify triple quoted (`\"\"\"...\"\"\"`) documentation of function purpose/arguments known as \"docstrings\". When this is supplied, we can use the `help` function (or append a `?` _after_ the function name) to print whatever documentation was included in the function when it was defined.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check custom function documentation\nhelp(mult_py)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHelp on function mult_py in module __main__:\n\nmult_py(n, i)\n    Multiply two values by one another.\n\n    n -- First value to multiply\n    i -- Second value to multiply\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Function Defaults\n\nSometimes a given argument will often be set to the same value. In cases like this, we can define that as the default of the argument which allows users to not specify that argument at all. When users do specify something for that argument, it overrides the default behavior. All functions (and [{{< fa brands python >}}]{.py} [Python methods]{.py}) with \"optional\" arguments are using defaults behind the scenes to make those arguments optional.\n\nWe can define these defaults when we first create a function! Let's make a simple division function that divides the first argument by the second and sets the default of the second argument to 2.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nWrite and demonstrate the simple division function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define function\ndiv_r <- function(p, q = 2){\n  \n  # Do division\n  result_r <- p / q\n  \n  # Return that\n  return(result_r)\n}\n\n# Test this function\ndiv_r(p = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\nUse the function again but set the second argument ourselves.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Specify the second argument\ndiv_r(p = 10, q = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nWrite and demonstrate the simple division function.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Define function\ndef div_py(n, i = 2):\n  # Write function documentation\n  \"\"\"\n  Divide the first value by the second\n  \n  n -- Numerator\n  i -- Denominator\n  \"\"\"\n  \n  # Do division\n  result_py = n / i\n  \n  # Return that\n  return result_py\n\n# Use the function with the default\ndiv_py(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5.0\n```\n\n\n:::\n:::\n\n\n\n\nUse the function again but set the second argument ourselves.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Specify the second argument\ndiv_py(n = 10, i = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.0\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Functions & Conditionals\n\nJust like loops, we can build conditional statements into our functions to make them more flexible and broadly useful. Let's combine this with setting default values to demonstrate this effectively.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nLet's make a simple addition function and set both arguments to default to `NULL`. `NULL` is an [{{< fa brands r-project >}}]{.r} [R]{.r} constant that allows us to create an object without assigning any value to it.\n\nNote that we're also using the `is.null` function in our conditional in order to easily assess whether the argument has been left to its default (i.e., set to `NULL`) or defined.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define addition function\nadd_r <- function(p = NULL, q = NULL){\n  \n  # If first argument is missing, set it to 2\n  if(is.null(p) == TRUE){\n    p <- 2\n  }\n  \n  # Do the same for the second argument\n  if(is.null(q) == TRUE){\n    q <- 2\n  }\n  \n  # Sum the two arguments\n  result_r <- p + q\n  \n  # Return that\n  return(result_r)\n}\n```\n:::\n\n\n\n\nNow let's use the function without specifying either argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use the function\nadd_r()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nLet's make a simple addition function and set both arguments to default to `None`. `None` is a [{{< fa brands python >}}]{.py} [Python]{.py} constant that allows us to create a variable without assigning any value to it.\n\nNote that we're also using the `is` statement in our conditional (in this case it is equivalent to `==`).\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Define addition function\ndef add_py(n = None, i = None):\n  # Add documentation\n  \"\"\"Add two values (`n` and `i`)\"\"\"\n\n  # If first argument is missing, set it to 2\n  if n is None:\n    n = 2\n\n  # Do the same for the second argument\n  if i is None:\n    i = 2\n  \n  # Sum the two arguments\n  result_py = n + i\n  \n  # Return that\n  return result_py\n```\n:::\n\n\n\n\nNow let's use the function without specifying either argument.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Use the function\nadd_py()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4\n```\n\n\n:::\n:::\n\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}