{
  "hash": "65deb7ed7c8aba0e08020dd5fa6b662b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Subsetting Data\"\n---\n\n\n\n\n## Library Loading\n\nBegin by loading any needed libraries.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nLoad the `tidyverse` meta-package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nLoad the `pandas` and `os` libraries.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Load needed libraries\nimport os\nimport pandas as pd\n```\n:::\n\n\n\n:::\n\n## Conditionals\n\nOften when we work with data we want to retrieve only the rows that meet some condition(s). These conditions can be defined in code by using \"relational operators\". Fortunately, the fundamental relational operators are the same between [{{< fa brands python >}} Python]{.py} and [{{< fa brands r-project >}} R]{.r}!\n\nConditional statements always return \"boolean\" [BOO-lee-un] values. These are [type]{.py} boolean and [class]{.r} logical in [{{< fa brands python >}} Python]{.py} and [{{< fa brands r-project >}} R]{.r} respectively.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nIn [{{< fa brands r-project >}} R]{.r} `TRUE` and `FALSE` are booleans. Note that their abbreviations `T` and `F` are also accepted though they _must_ be capitalized.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assess whether a number equals itself and assign to an object\nbool_r <- 20 == 20\n\n# See what that object contains\nbool_r\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# And check class\nclass(bool_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nIn [{{< fa brands python >}} Python]{.py} `True` or `False` are booleans. Note that they must be capitalized in this way to register as the correct type (i.e., only first letter capitalized).\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Assess whether a number equals itself and assign to an object\nbool_py = 20 == 20\n\n# See what that object contains\nbool_py\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Also check type\ntype(bool_py)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'bool'>\n```\n\n\n:::\n:::\n\n\n\n:::\n\nIn addition to asking whether something 'is exactly equal to' something else (`==`), we can also ask whether two values are _not_ equal (`!=`) or pose greater/less than conditionals (`>`/`<`).\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ask whether a number is less than or equal to a particular value\n7 <= 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Ask whether a number is less than or equal to a particular value\n7 <= 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Subset with One Condition\n\nWe can leverage these conditional values to return only rows of a data table that meet criteria that are valuable to us. Let's begin by loading the external dataset derived from the `lterdatasampler` [{{< fa brands r-project >}} R]{.r} package (see [here](https://lter.github.io/lterdatasampler/)) that we used in the previous section.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nRead in vertebrate data CSV and check out the first few rows.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nvert_r <- utils::read.csv(file = file.path(\"data\", \"verts.csv\"))\n\n# Check out first few rows\nhead(vert_r, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year sitecode section reach pass unitnum unittype vert_index pitnumber\n1 1987 MACKCC-L      CC     L    1       1        R          1        NA\n2 1987 MACKCC-L      CC     L    1       1        R          2        NA\n3 1987 MACKCC-L      CC     L    1       1        R          3        NA\n          species length_1_mm length_2_mm weight_g clip sampledate notes\n1 Cutthroat trout          58          NA     1.75 NONE 1987-10-07      \n2 Cutthroat trout          61          NA     1.95 NONE 1987-10-07      \n3 Cutthroat trout          89          NA     5.60 NONE 1987-10-07      \n```\n\n\n:::\n:::\n\n\n\n\nRecall from our file path module that the `file.path` function accounts for computer operating system differences.\n\n## [{{< fa brands python >}} Python]{.py}\n\nRead in vertebrate data CSV (remember we _must_ namespace the `read_csv` function) and check out the first few rows.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Load data\nvert_py = pd.read_csv(os.path.join(\"data\", \"verts.csv\"))\n\n# Check out first few rows\nvert_py.head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   year  sitecode section reach  ...  weight_g  clip  sampledate  notes\n0  1987  MACKCC-L      CC     L  ...      1.75  NONE  1987-10-07    NaN\n1  1987  MACKCC-L      CC     L  ...      1.95  NONE  1987-10-07    NaN\n2  1987  MACKCC-L      CC     L  ...      5.60  NONE  1987-10-07    NaN\n\n[3 rows x 16 columns]\n```\n\n\n:::\n:::\n\n\n\n\nRecall from our file path module that the `join` function accounts for computer operating system differences.\n:::\n\nNow that we have some data we can use conditional statements to actually subset it! We'll use the `len` and `nrow` functions in [{{< fa brands python >}} Python]{.py} and [{{< fa brands r-project >}} R]{.r} respectively to demonstrate that we successfully subset. Either will show whether we've successfully removed the rows that don't meet our criteria.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nLet's subset to only one particular site of vertebrate data. Note that base [{{< fa brands r-project >}} R]{.r} does include a `subset` function but we'll use the equivalent `filter` function from the `dplyr` package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset to only site \"MACKOG-U\"\nr_sub1 <- dplyr::filter(vert_r, sitecode == \"MACKOG-U\")\n\n# Check whether that worked\nmessage(\"Before subsetting the data had \", nrow(vert_r), \" rows.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Subsetting changed this to \", nrow(r_sub1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSubsetting changed this to 5726\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nLet's subset to only one particular site of vertebrate data.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Subset to only site \"MACKOG-U\"\npy_sub1 = vert_py[vert_py.sitecode == \"MACKOG-U\"]\n\n# Check whether that worked\nprint(\"Before subsetting the data had\", len(vert_py), \"rows.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"Subsetting changed this to\", len(py_sub1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubsetting changed this to 5726\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Subset with Multiple Conditions\n\nIf desired we can also specify multiple criteria to subset by. We must decide whether _all_ criteria must be met or if _any_ criterion being met is sufficient to retain the row. If we want **all** (in either language) we need to separate each criterion with an ampersand (`&`). If instead we want **any** (in either language) we need to separate each criterion with a pipe (`|`); note that this is _not_ the same as a \"pipe operator\" which we'll discuss in detail later.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nIf we want a only values between a minimum and maximum value that means we need all criteria to be met so we need to use a `&` between conditions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset to only data from after 1990 before 1995 (inclusive)\nr_sub2 <- dplyr::filter(vert_r, year >= 1990 & year <= 1995)\n\n# Check whether that worked\nmessage(\"Before subsetting the data had \", nrow(vert_r), \" rows.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Subsetting changed this to \", nrow(r_sub2))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSubsetting changed this to 4161\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nIf we want a only values between a minimum and maximum value that means we need all criteria to be met so we need to use a `&` between conditions. Note that when we specify multiple criteria in [{{< fa brands python >}} Python]{.py} we _must_ wrap each conditional in parentheses.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Subset to only data from after 1990 before 1995 (inclusive)\npy_sub2 = vert_py[(vert_py.year >= 1990) & (vert_py.year <= 1995)]\n\n# Check whether that worked\nprint(\"Before subsetting the data had\", len(vert_py), \"rows.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"Subsetting changed this to\", len(py_sub2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubsetting changed this to 4161\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Subset with Masks\n\nWe can define \"boolean masks\" when we want to leverage a helper function that tests for specific crtieria. For instance we can use the `isin` [method]{.py} or the `%in%` [operator]{.r} (in [{{< fa brands python >}} Python]{.py} and [{{< fa brands r-project >}} R]{.r} respectively) to ask whether the value in a given row matches any of a set of options. This is much simpler than writing out one \"or\" criterion for every option individually.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nLet's subset to only salamander species in the dataset using a mask. In [{{< fa brands r-project >}} R]{.r}, that means providing the column name to the left of the `%in%` operator and giving a vector of options to the right.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make the subset\nr_mask1 <- dplyr::filter(vert_r, species %in% c(\"Coastal giant salamander\", \"Cascade torrent salamander\"))\n\n# Check whether that worked\nmessage(\"Before subsetting the data had \", nrow(vert_r), \" rows.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Subsetting changed this to \", nrow(r_mask1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSubsetting changed this to 11773\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nLet's subset to only salamander species in the dataset using a mask. In [{{< fa brands python >}} Python]{.py}, `isin` is a method so it is appended to the right of the column it accesses (separated by a period) and the options must be provided as a list (i.e., wrapped in square brackets and separated by commas).\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Make the subset\npy_mask1 = vert_py[vert_py.species.isin([\"Coastal giant salamander\", \"Cascade torrent salamander\"])]\n\n# Check whether that worked\nprint(\"Before subsetting the data had\", len(vert_py), \"rows.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"Subsetting changed this to\", len(py_mask1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubsetting changed this to 11773\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Negating Criteria\n\nSometimes it is helpful to _negate_ criteria and subset to only conditions that _don't_ meet our criteria. This works with either simpler conditional statements or with masks! The symbol we use to do this negation differs between the two languages but in either it is placed to the left of the criterion it is negating.\n\nIn the below example we'll use the `isnull` [function]{.py} or the `is.na` [function]{.r} to see whether a column contains missing values and invert it to return only rows where the specified column _is not_ missing values.\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\nIn [{{< fa brands r-project >}} R]{.r} we negate conditions by adding an exclamation point (`!`) to the left of the relevant criterion.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset to only species that *have* a recorded value in the \"length_2_mm\" column\nr_mask2 <- dplyr::filter(vert_r, !is.na(length_2_mm))\n\n# Check whether that worked\nmessage(\"Before subsetting the data had \", nrow(vert_r), \" rows.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Subsetting changed this to \", nrow(r_mask2))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSubsetting changed this to 12560\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\nIn [{{< fa brands python >}} Python]{.py} we negate conditions by adding a tilde (`~`) to the left of the relevant criterion.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Subset to only species that *have* a recorded value in the \"length_2_mm\" column\npy_mask2 = vert_py[~pd.isnull(vert_py.length_2_mm)]\n\n# Check whether that worked\nprint(\"Before subsetting the data had\", len(vert_py), \"rows.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"Subsetting changed this to\", len(py_mask2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubsetting changed this to 12560\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Partial String Matching\n\nWe can also filter by instances where part of a larger [string]{.py}/[character]{.r} matches a specific pattern. This type of criterion is known as \"partial string matching\".\n\n:::panel-tabset\n## [{{< fa brands r-project >}} R]{.r}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset to only rows where the 'species' column includes the word \"salamander\"\nr_part <- dplyr::filter(vert_r, stringr::str_detect(string = species, pattern = \"salamander\"))\n\n# Check whether that worked\nmessage(\"Before subsetting the data had \", nrow(vert_r), \" rows.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Subsetting changed this to \", nrow(r_part))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSubsetting changed this to 11773\n```\n\n\n:::\n:::\n\n\n\n\n## [{{< fa brands python >}} Python]{.py}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Remove rows missing species information\npy_knownsp = vert_py[~pd.isnull(vert_py.species)]\n\n# Subset to only rows where the 'species' column includes the word \"salamander\"\npy_part = py_knownsp[py_knownsp[\"species\"].str.contains(\"salamander\")]\n\n# Check whether that worked\nprint(\"Before subsetting the data had\", len(vert_py), \"rows.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBefore subsetting the data had 32209 rows.\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"Subsetting changed this to\", len(py_part))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubsetting changed this to 11773\n```\n\n\n:::\n:::\n\n\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}