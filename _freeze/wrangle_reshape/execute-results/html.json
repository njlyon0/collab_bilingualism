{
  "hash": "5731a44711992a623ea27259b1995f73",
  "result": {
    "markdown": "---\ntitle: \"Reshaping Data\"\n---\n\n\n## Library & Data Loading\n\nBegin by loading any needed libraries and reading in an external data file for use in downstream examples.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\nLoad the `tidyverse` meta-package as well as our simulated lichen data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load needed library\nlibrary(tidyverse)\n\n# Load data\nlich_r <- read.csv(file = file.path(\"data\", \"tree_lichen.csv\"))\n\n# Check out first few rows\nhead(lich_r, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    tree lichen_foliose lichen_fruticose lichen_crustose\n1 Tree_A           1.00              0.9            0.95\n2 Tree_B           0.35              1.0            0.00\n3 Tree_C           0.20              0.0            0.05\n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nLoad the `pandas` and `os` libraries as well as our simulated lichen data.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Load needed libraries\nimport os\nimport pandas as pd\n\n# Load data\nlich_py = pd.read_csv(os.path.join(\"data\", \"tree_lichen.csv\"))\n\n# Check out first few rows\nlich_py.head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     tree  lichen_foliose  lichen_fruticose  lichen_crustose\n0  Tree_A            1.00               0.9             0.95\n1  Tree_B            0.35               1.0             0.00\n2  Tree_C            0.20               0.0             0.05\n```\n:::\n:::\n\n:::\n\n## Understanding Data Shape\n\nAll tabular data can be said to have a \"shape\" that is either **wide** or **long**. This is often used to simply indicate whether there are more columns than there are rows but it is perhaps more accurate to say that _wide_ data have variables in separate columns while _long_ data usually has a column of variable names and a column of values. This distinction is important because you can have a data table with more rows than columns that is still in wide format (e.g., the simulated example lichen community data we just loaded).\n\nWhen wrangling data we may find it necessary to change the data from one shape to the other--this process is what is meant by \"reshaping\" (or sometimes \"pivoting\"). An example of each type of reshaping is included below.\n\n## Reshaping Longer\n\nOur lichen data are currently in wide format so let's reshape into long format.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\n[{{< fa brands r-project >}} R]{.r} uses the `pivot_longer` function from the `tidyr` package for this operation. We need to specify the data table to reshape, the columns to collapse (to the `cols` argument), as well as the new column names for both the old column names and the values they contained. Fortunately the `names_to` and `values_to` arguments are reasonably intuitively named.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reshape longer\nlong_r <- tidyr::pivot_longer(data = lich_r,\n                              cols = c(lichen_foliose, lichen_fruticose, lichen_crustose),\n                              names_to = \"lichen_types\",\n                              values_to = \"percent_cover\")\n\n# Check out the first few rows of that\nhead(long_r, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  tree   lichen_types     percent_cover\n  <chr>  <chr>                    <dbl>\n1 Tree_A lichen_foliose            1   \n2 Tree_A lichen_fruticose          0.9 \n3 Tree_A lichen_crustose           0.95\n```\n:::\n:::\n\n\nNote that the column names to reshape _must_ be a vector.\n\n## [{{< fa brands python >}}]{.py} Python\n\n[{{< fa brands python >}} Python]{.py} uses the `melt` function from the `pandas` library for this operation. We need to specify the DataFrame to reshape, the columns to _exclude_ from collapsing (with the `id_vars` argument), as well as the new column names for both the old column names and the values they contained. Fortunately the `var_name` and `value_name` arguments are reasonably intuitively named.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Reshape longer\nlong_py = pd.melt(frame = lich_py,\n                  id_vars = [\"tree\"],\n                  var_name = \"lichen_types\",\n                  value_name = \"percent_cover\")\n\n# Check out the first few rows of that\nlong_py.head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     tree    lichen_types  percent_cover\n0  Tree_A  lichen_foliose           1.00\n1  Tree_B  lichen_foliose           0.35\n2  Tree_C  lichen_foliose           0.20\n```\n:::\n:::\n\n\nNote that the column names use as IDs _must_ be a list (or similar object type).\n:::\n\n## Reshaping Wider\n\nThe opposite operation--reshaping wider--is also readily available in either [{{< fa brands python >}} Python]{.py} or [{{< fa brands r-project >}} R]{.r}. We'll reshape the data we made into long format above to demonsrate re-reshaping back into wide format.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\n[{{< fa brands r-project >}} R]{.r} uses the `pivot_wider` function (also from the `tidyr` package) to do this type of reshaping operation. Reshaping wider requires fewer arguments as only the columns to reshape need to be specified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reshape (back) into wide format\nwide_r <- tidyr::pivot_wider(data = long_r,\n                             names_from = \"lichen_types\",\n                             values_from = \"percent_cover\")\n\n# Check out the first few rows\nhead(wide_r, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  tree   lichen_foliose lichen_fruticose lichen_crustose\n  <chr>           <dbl>            <dbl>           <dbl>\n1 Tree_A           1                 0.9            0.95\n2 Tree_B           0.35              1              0   \n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nWe can use the `pandas` function `pivot_table` to reshape back into wide format. Unlike [{{< fa brands r-project >}} R]{.r}, we do need to specify the `index` column label(s) that are not being reshaped.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Reshape (back) into wide format\nwide_py = pd.pivot_table(data = long_py,\n                         index = [\"tree\"], \n                         columns = \"lichen_types\",\n                         values = \"percent_cover\")\n                         \n# Do some small index reformatting steps\nwide_py = wide_py.reset_index().rename_axis(mapper = None, axis = 1)\n\n# Check out the first few rows\nwide_py.head(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     tree  lichen_crustose  lichen_foliose  lichen_fruticose\n0  Tree_A             0.95            1.00               0.9\n1  Tree_B             0.00            0.35               1.0\n```\n:::\n:::\n\n\nThe reset index step is needed to get the index to look like it did before we `melt`ed it.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}