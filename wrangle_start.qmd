---
title: "Starting with Data"
engine: knitr
---

## Overview

Once you get a sense for the core rules of your programming language of choice, you can move on to working with a data table that is more realistically complex.

## Library Loading

This section assumes you've already _installed_ the needed python / R packages. See the chunks in the home page of this website if you need a refresher on which packages are needed. However, it is not enough to install a package onto a given computer, you also have to specifically load that library into your working environment for its functions to be available to you in a specific script / document.

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

R libraries are loaded with the `library` function.

```{r r-libs, warning = F, message = F}
library(tidyverse)
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

Python libraries are loaded with the `import` statement and can be aliased into simpler names with `as` at the same time. Note that common libraries (like Pandas) have a broadly-accepted abbreviation that is almost always used (like `pd` in the case of Pandas.)

```{python py-libs}
import pandas as pd
```
:::

## Data Import

We can now load an external dataset derived from the `lterdatasampler` R package (see [here](https://lter.github.io/lterdatasampler/)) with both R and python. This relatively simple operation is also a nice chance to showcase how 'namespacing' (i.e., indicating which package a given function comes from) differs between the two languages.

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

Namespacing in R is accomplished by doing `package_name::function_name` and is optional (though, in my opinion, good practice!). Note that we use the assignment operator (`<-`) to assign the contents of the CSV to an object.

```{r r-ext-data}
# Read in vertebrate data CSV
vert_r <- utils::read.csv(file = "data/verts.csv")
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

In Python, namespacing is required and is done via `package_name.function_name`. Note that we use the assignment operator (`<-`) to assign the contents of the CSV to a variable.

```{python py-ext-data}
# Read in vertebrate data CSV
vert_py = pd.read_csv("data/verts.csv")
```
:::

## Tabular Data <span style="color:#077DC2">Type</span>/<span style="color:#FF9B00">Class</span>

Data stored in CSVs (and similar data formats like Microsoft Excel, etc.) has a unique <span style="color:#077DC2">type</span>/<span style="color:#FF9B00">class</span> that differs from some of the categories we covered in the "Fundamentals" section.

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

In R, such data are class `data.frame`

```{r r-class}
# Check class of a data object
class(vert_r)
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

In Python, such data are type `DataFrame` and this variable type is defined by the Pandas library. This is the standard type returned by the Pandas `read_csv` function.

```{python py-class}
# Check type of a data object
type(vert_py)
```
:::

## Making Heads or Tails of Data

Checking the 'head' or 'tail' of the data (i.e., the first or last few rows of the data respectively) is a nice way of getting a sense for the general format of the dataframe being assessed.

::: panel-tabset
## `r fontawesome::fa("r-project", fill = "#FF9B00", a11y = "sem")` R

In R, we use the `head` or `tail` function and can use an optional `n` argument to specify the number of rows to return as an integer (default is 6 rows).

```{r r-head}
# Check out head
utils::head(vert_r, n = 2)
```

```{r r-tail}
# Check out tail
utils::tail(vert_r, n = 3)
```

## `r fontawesome::fa("python", fill = "#077DC2", a11y ="sem")` Python

In Python, we also use a `head` or `tail` tool but here it is a "method" available to any variable of type `DataFrame`. All methods are appended to the end of the variable of the appropriate type separated by a period.

Both the `head` and `tail` methods allow specifying an integer number of rows to return (the default is 5).

```{python py-head}
# Check out head
vert_py.head(3)
```

```{python py-tail}
# Check out tail
vert_py.tail(2)
```
:::

## Data Structure

While it is nice to know the <span style="color:#077DC2">type</span>/<span style="color:#FF9B00">class</span> of the data table generally, we often need to know the <span style="color:#077DC2">type</span>/<span style="color:#FF9B00">class</span> of the columns within those data tables. Our operations are typically aimed at modifying particular columns and pre-requisite to that is knowing the <span style="color:#077DC2">type</span>/<span style="color:#FF9B00">class</span> of the column to know what actions are available to us.

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

R uses the `str` function to assess data structure (not to be confused with the Python type "str" that is short for "string). Structure includes the dimensions of the data (i.e., number of rows and columns) as well as the class of the data (`data.frame`) and the class of each column.

```{r r-structure}
utils::str(vert_r)
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

When we want to know the type of each column in a Python `DataFrame`, we can use the `dtypes` "attribute". Attributes are akin to a method but they completely lack arguments that might modify their behavior. As a consequence they are extremely precisely defined. The `dtypes` attribute returns the type of each column.

```{python py-structure}
vert_py.dtypes
```
:::

## Accessing Column(s)

We may want to access a particular column or set of columns. There are several approaches we might use to access a particular column in either Python or R. They are:

- Indexing the column by its location
- Indexing the column by its <span style="color:#077DC2">label</span>/<span style="color:#FF9B00">name</span>
- Indexing the column with an operator

In all of the following examples we'll use the `head` <span style="color:#077DC2">method</span>/<span style="color:#FF9B00">function</span> to simplify the output.

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

If we know the order of the columns we can use the same syntax as when we indexed a vector.

```{r r-cols1}
# Use column indexing
head(vert_r[1])
```

Note that if we also want to account for rows we would put the desired column number on the right and the desired row number on the left.

```{r r-cols1b}
# Use row/column indexing
head(vert_r[, 1])
```

If preferred we could instead substitute the number for the column name.

```{r r-cols2}
head(vert_r["year"])
```

In R, the column operator is a `$` and we place that character between the object and column names (e.g., `data_name$column_name`).

```{r r-cols3}
head(vert_r$year)
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

If we know the index position of the desired column we can use the `iloc` method (short for "integer location"). Note that the `iloc` method uses square brackets instead of parentheses (typical methods use parentheses). We must include a colon with either nothing or the start/stop bounds (see "Slicing" in "Fundamentals"). A colon without specifying bounds returns all rows.

```{python py-cols1}
# Use row/column indexing
vert_py.iloc[: , 0].head()
```

If preferred we could instead substitute the number for the column label.

```{python py-cols2}
vert_py["year"].head()
```

In R, the column operator is a `.` and we place that character between the variable name and column label (e.g., `data_name.column_name`).

```{python py-cols3}
vert_py.year.head()
```
:::

When we want to access multiple columns we can still use either index positions or column <span style="color:#077DC2">labels</span>/<span style="color:#FF9B00">names</span> but we _cannot_ use the column operator.

We'll continue to use the `head` <span style="color:#077DC2">method</span>/<span style="color:#FF9B00">function</span> to simplify outputs.

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

In R we could use a concatenated vector of index positions to specify particular columns by their positions.

```{r r-multicols1}
# Use multiple column index positions
head(vert_r[, c(1:2, 13)])
```

Instead we could use a vector of column names for extra precision.

```{r r-multicols2}
# Use multiple column names
head(vert_r[, c("year", "sitecode", "weight_g")])
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

In Python we could use the `iloc` method for multiple columns and simply supply a list of the column index positions in which we are interested.

```{python py-multicols1}
# Use multiple column index positions
vert_py.iloc[:, [0, 1, 12]].head()
```

Or we could use the `.loc` method and supply a list of column labels. Note that the `loc` method also uses square brackets instead of parentheses and requires a colon to the left of the column in order to return all rows.

```{python py-multicols2}
vert_py.loc[:, ["year", "sitecode", "weight_g"]].head()
```
:::

