{
  "hash": "5344ce03b8ce1058ad1d05a32e2abe61",
  "result": {
    "markdown": "---\ntitle: \"Core Concepts\"\n---\n\n\n## Overview\n\nThis section covers some of the most fundamental operations of both languages. These include [variable]{.py}/[object]{.r} assignment, data [type]{.py}/[class]{.r}, arithmetic, etc. External data are _not_ included in this page.\n\nNote that any line in a code chunk preceded by a hashtag (`#`) is a \"comment\" and is not evaluated in either language. Including comments is generally good practice because it allows humans to read and understand code that may otherwise be unclear to them.\n\n## Assignment\n\nAt its most basic, we want to store data in code in such a way that we can use / manipulate it via our scripts. This requires **assigning** data to a [variable]{.py}/[object]{.r} with the **assignment operator**.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\nIn [{{< fa brands r-project >}} R]{.r}, the assignment operator is `<-`. To use it, the name of the new object-to-be is on the left of the arrow and the information to assign is on the right.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a simple object\na <- 2\n\n# Check it out\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nIn [{{< fa brands python >}} Python]{.py}, the assignment operator is `=`. To use it, the name of the new object-to-be is on the left of the equal sign and the information to assign is on the right.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Make a simple object\na = 2\n\n# Check it out\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n:::\n\nOnce we've created a [variable]{.py}/[object]{.r} we can then use the information stored inside of it in downstream operations! For example, we could perform basic arithmetic on our [variable]{.py}/[object]{.r} and assign the result to a new [variable]{.py}/[object]{.r}.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\nAddition, subtraction, multiplication, and division share operators across both languages (`+`, `-`, `*`, and `/` respectively). However, in [{{< fa brands r-project >}} R]{.r} exponents use `^`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Raise to an exponent\nb <- a^3\n\n# Check out the result\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nAddition, subtraction, multiplication, and division share operators across both languages (`+`, `-`, `*`, and `/` respectively). However, in [{{< fa brands python >}} Python]{.py} exponents use `**`\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Raise to an exponent\nb = a**3\n\n# Check out the result\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8\n```\n:::\n:::\n\n:::\n\n## [Type]{.py} & [Class]{.r}\n\nSome operations are only possible on some categories of information. For instance, we can only perform arithmetic on numbers. In [{{< fa brands python >}} Python]{.py} this is known as the [variable]{.py}'s [type]{.py} & while in [{{< fa brands r-project >}} R]{.r} this is the [object]{.r}'s [class]{.r}. In either case, it's important to know--and be able to check--this information about the [variables]{.py}/[objects]{.r} with which we are working.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\nIn [{{< fa brands r-project >}} R]{.r} we use the `class` function to get this information. Note that the names of [{{< fa brands r-project >}} R]{.r} classes sometimes differ from their equivalents in [{{< fa brands python >}} Python]{.py}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check class of an integer\nclass(37)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check class of a decimal\nclass(3.14159)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check class of text\nclass(\"my hands are typing words\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nIn [{{< fa brands python >}} Python]{.py}, the `type` function returns the type of the data object. Note that the names of [{{< fa brands python >}} Python]{.py} types sometimes differ from their equivalents in [{{< fa brands r-project >}} R]{.r}.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check type of an integer\ntype(37)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'int'>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check type of a decimal\ntype(3.14159)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'float'>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check type of text\ntype(\"my hands are typing words\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'str'>\n```\n:::\n:::\n\n:::\n\n## Indexing\n\nWhen our [variables]{.py}/[objects]{.r} have more than one [item]{.py}/[element]{.r} we may want to examine the piece of information at a specific position. This position is the \"index position\" and can be accessed in either language fairly easily.\n\nIn order to explore this more fully, let's make some example multi-component [variables]{.py}/[objects]{.r}.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\nIn [{{< fa brands r-project >}} R]{.r}, one of the fundamental data structures is a \"vector\". Vectors are assembled with the concatenation function (`c`) where each item is separated by commas (`,`) and the set of them is wrapped in parentheses (`(...)`).\n\nNote that the class of the object comes from the vector's _contents_ rather than the fact that it is a vector. All elements in a vector therefore must share a class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a multi-item variable\nx <- c(1, 2, 3, 4, 5)\n\n# Check it out\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nIn [{{< fa brands python >}} Python]{.py} the fundamental data structure is a \"list\". Lists are assembled either by wrapping the items to include in square brackets (`[...]`) or by using the `list` function. In either case, each item is separated from the others by commas (`,`).\n\nNote that the type of the variable comes from the _list itself_ rather than its contents. Lists therefore support items of multiple different types.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Make a multi-item variable\nx = [1, 2, 3, 4, 5]\n\n# Check it out\ntype(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'list'>\n```\n:::\n:::\n\n:::\n\nOne crucial difference between [{{< fa brands r-project >}} R]{.r} and [{{< fa brands python >}} Python]{.py} is that [{{< fa brands python >}} Python]{.py} is \"0-based\" meaning that the first [item]{.py} is at index position `0` while in [{{< fa brands r-project >}} R]{.r} the position of the equivalent [element]{.r} is `1`.\n\nFortunately, in either language the syntax for indexing is the same.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\nTo index a multi-element object, simply append square brackets to the end of the object name and specify the number of the index position in which you are interested.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the first element of the vector\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nTo index a multi-item variable, simply append square brackets to the end of the variable name and specify the number of the index position in which you are interested.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Access the first item of the list\nx[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n:::\n\n## Slicing\n\nWhen we index more than one position, this is known as \"slicing\". We can still use square brackets in either language to slice multiple [items]{.py}/[elements]{.r} and the syntax inside of those brackets _seems_ shared but yields different results due to inherent syntactical differences.\n\n:::panel-tabset\n## [{{< fa brands r-project >}}]{.r} R\n\nIn [{{< fa brands r-project >}} R]{.r}, when we write two numbers separated by a colon (`:`), that indicates that we want those two numbers and all integers between them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Demonstrate that the colon is shorthand for 'all numbers between'\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nWe can use this to slice out multiple _continuous_ index positions from an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Slice items in the `x` object\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4\n```\n:::\n:::\n\n\n## [{{< fa brands python >}}]{.py} Python\n\nIn order to slice in [{{< fa brands python >}} Python]{.py}, we include the start and stop _bounds_ of the items that we want to slice separated by a colon (`:`) inside of square brackets. The first bound (i.e., bound position 0) is actually the starting bracket of the list! This means that we can treat the first number in the slice in the same way we would in single indexing but the second number is actually the bound before the item with that index value.\n\nAnother way of thinking about this is that it is similar to a mathematical set. The starting bound is _inclusive_ while the ending bound is _exclusive_.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Strip out several items of the Python list\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3, 4]\n```\n:::\n:::\n\n\nNotice that we only get the items at third and fourth index position despite `4` being after the colon (which in an index would return the fifth index position)? That is because the fourth bound is after the fourth item but _before_ the fifth item.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}