---
title: "Workflow Automation"
---

## Loops

Often we want to perform some set of operations repeatedly across a known number of iterations. For example, maybe we want to subset a given data file into a separate <span style="color:#077DC2">variable</span>/<span style="color:#FF9B00">object</span> by month of data collection and export the resulting file as a CSV. We _could_ simply copy/paste our 'subset and export' code as many times as needed but this can be error-prone. Also, it is cumbersome to manually update all copies of the relevant code when you identify a possible improvement. 

One code solution to this is to **automate** the workflow using `for` loops (casually referred to more simply as just "loops"). The syntax of `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` <span style="color:#077DC2">Python</span> and `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` <span style="color:#FF9B00">R</span> is very similar for loops--likely because this is such a fundamental operation to any coding language!

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

Make a simple object to demonstrate loops.

```{r r-loop-prep}
# Make a vector of animal types
zoo_r <- c("lion", "tiger", "crocodile", "vulture", "hippo")

# Check that out
zoo_r
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

Make a simple variable to demonstrate loops.

```{python py-loop-prep}
# Make a list of animal types
zoo_py = ["lion", "tiger", "crocodile", "vulture", "hippo"]

# Check that out
zoo_py
```
:::

With this simple <span style="color:#077DC2">variable</span>/<span style="color:#FF9B00">object</span> in-hand we can now demonstrate the core facets of loops.

### Fundamental Components

Loops (in either language) require a few core components in order to work properly:

1. `for` statement -- defines the start of the loop-definition component
2. "Loop <span style="color:#077DC2">Variable</span>/<span style="color:#FF9B00">Object</span>" -- essentially a placeholder <span style="color:#077DC2">variable</span>/<span style="color:#FF9B00">object</span> whose value will change with each iteration of the loop
3. `in` statement -- relates loop <span style="color:#077DC2">variable</span>/<span style="color:#FF9B00">object</span> to set of <span style="color:#077DC2">list</span>/<span style="color:#FF9B00">vector</span> to iterate across
4. <span style="color:#077DC2">list</span>/<span style="color:#FF9B00">vector</span> to iterate across -- set of values to iterate across
5. Actual workflow! -- operations to perform on each iteration of the loop

To see in this syntax in action we'll use a simple loop that prints each animal type in the <span style="color:#077DC2">list</span>/<span style="color:#FF9B00">vector</span> we created above.

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

In R, the `for` statement requires parentheses around the loop object, the `in` statement, and the vector to iterate across. The operation(s) performed in each iteration _must_ be wrapped in curly braces (`{...}`).

When the code reaches the closing curly brace it returns to the top of the workflow and begins again with the next element of the provided vector.

```{r r-loop1}
# For each animal in the zoo
for(animal in zoo_r){
  
  # Print its name
  print(animal)
  
}
```

Note that when we are done the loop object still exists and is set to the last element of the vector we iterated across.

```{r r-loop2}
# Check current value of `animal` object
animal
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

In Python, the `for` statement, loop variable, `in` statement, and list to iterate across do not use parentheses but the end of the line requires a colon `:`. The operation(s) performed in each iteration _must_ be indentened one level (i.e., press "tab" once or "space" four times).

When the code reaches the end of the indented lines it returns to the top of the workflow and begins again with the next item of the provided list.

```{python py-loop1}
# For each animal in the zoo
for animal in zoo_py:
  # Print its name
  print(animal)
```

Note that when we are done the loop variable still exists and is set to the last item of the list we iterated across.

```{python py-loop2}
# Check current value of `animal` variable
animal
```
:::

### Loops & Conditionals

We can also build conditional statements into a loop to create a loop that can flexibly handle different outcomes. We have discussed conditional operators elsewhere so we'll only explain the parts of loop conditionals that we haven't already discussed. To demonstrate, we can loop across a set of numbers and use conditionals to print whether the values are greater/less than or equal to zero.

In the example below we'll use three new statements `if`, `else if` and `else`. Each condition only performs its operation when its condition is met (i.e., returns <span style="color:#077DC2">True</span>/<span style="color:#FF9B00">TRUE</span>).

:::panel-tabset
## `r fontawesome::fa(name = "r-project", fill = "#FF9B00", a11y = "sem")` R

These three statements all have similar syntax to the `for` statement in that they evaluate something in parentheses and then perform some operation(s) in curly braces. They do differ slightly in context however:

- `if` can only be used first (or in cases where there is only `if` and `else`)
- `else if` can only be used after `if` (or after another `else if`) and _allows for specifying another condition._
- `else` can only be used at the end; catches only cases that _don't_ meet one of the prior conditions

```{r r-condloop}
# Loop across numbers
for(j in c(-2, -1, 0, 1, 2)){
  
  # If less than 0
  if(j < 0){ 
    print(paste(j, "is negative")) 
    }
  
  # If greater than 0
  else if(j > 0){
    print(paste(j, "is positive"))
  }
  
  # If neither of those, then it must be 0!
  else { 
    print(paste(j, "is zero!"))
    }
}
```

## `r fontawesome::fa(name = "python", fill = "#077DC2", a11y = "sem")` Python

These three statements all have similar syntax to the `for` statement in that they evaluate something before a colon and then perform some operation(s) after that colon. They do differ slightly in context however:

- `if` can only be used first (or in cases where there is only `if` and `else`)
- `elif` can only be used after `if` (or after another `elif`) and _allows for specifying another condition._
- `else` can only be used at the end; catches only cases that _don't_ meet one of the prior conditions

```{python py-condloop}
# Loop across numbers
for k in [-2, -1, 0, 1, 2]:
  
  # If less than 0
  if k < 0: 
    print(str(k) + " is negative")
    
  # If greater than 0
  elif k > 0:
    print(str(k) + " is positive")
  
  # If neither of those, then it must be 0!
  else:
    print(str(k) + " is zero!")
```
:::

## "Custom" Functions

